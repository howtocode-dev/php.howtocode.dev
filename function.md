# ফাংশন

ফাংশন মুলত কিছু স্টেটমেন্টের একটি ব্লক যা একটি প্রোগ্রামে বার বার ব্যবহার করা যায় পুনরায় না লিখে। পিএইচপিতে ১০০০ এর অধিক বিল্টইন ফাংশন আছে , যেগুলো ব্যবহারের
জন্য আপনাকে শুধু সেগুলো কল করতে হবে। এছাড়াও আপনি চাইলে আপনার মনমত ফাংশন লিখে নিতে পারেন। 
###বিল্টইন ফাংশনঃ
```php
<?php
var_dump("This is .....");
?>
```

###ইউজার ডিফাইন ফাংশনঃ
```php
<?php
function sayHello($name)
{
    return "Hello {$name}!";
}
?>
```
যেহেতু বিল্টইন ফাংশন গুলো শুধু তাদের ডকুমেন্টেশন অনুযায়ী ব্যবহার করা যায় এবং এর জন্য প্রচুর সাপোর্ট রয়েছে তাই আলোচনা সেদিকে আলোচনা না করে ইউজার ডিফাইন ফাংশন নিয়ে করছি। 

###সিনট্যাক্সঃ
যেকোন ইউজার ডিফাইন ফাংশন লিখতে হলে আপনাকে নিচের সিনট্যাক্স অনুসরণ করতে হবে। 
```php
<?php
function functionName($arg1,$arg2)
{
    // কোড ব্লক 
}
?>
```
>ফাংশনের নাম অবশ্যই ইউনিক হতে হবে, নাম অবশ্যই লেটার অথবা আন্ডারস্কোর `_` দিয়ে শুরু করতে হবে। নামের মধ্যখানে কোন স্পেস দেওয়া যাবে না, প্রয়োজনে আন্ডারস্কোর  `_` ব্যবহার করতে হবে। একটি ইউজার ডিফাইন ফাংশনকে কল করার আগে তাকে ডিক্লেয়ার করে নিতে হবে।  ইউজার ডিফাইন ফাংশনে আর্গুমেন্ট+রিটার্ন থাকতে পারে নাও থাকতে পারে। নিচে কিছু উদাহরন দেওয়া হল।

###আর্গুমেন্ট  কি?
 ফাংশন তার বাইরে ডিক্লেয়ার করা ভ্যারিয়েবল থেকে ভ্যালু নিতে পারে না। তাই ফাংশনের ব্যবহারের জন্য যদি কোন ভ্যারিয়েবলে ভ্যালুর প্রয়োজন হয় তবে তা আর্গুমেন্টের মাধ্যমে ফাংশনের কাছে পাস করতে হয়। সহজ ভাষায় আর্গুমেন্ট হচ্ছে  ফাংশনের ইনপুট। অর্থাৎ ফাংশনের মধ্যে কোন ভ্যালু পাস করাতে হবে আর্গুমেট ব্যবহার করতে হবে।
 
 
###আর্গুমেন্ট ছাড়াঃ
```php
<?php
function functionName()
{
   echo "Hi i don't have any argument!";
}
?>
```
এই ফাংশনটিতে  কোন আর্গুমেন্ট নেই। অর্থাৎ একে কল করার সময় কোন আর্গুমেন্ট পাস করাতে হবে না। অনেকটা এই রকম করে  `functionName();`

###আর্গুমেন্ট সহঃ
```php
<?php
function functionName($arg1,$arg2)
{
   echo $arg1;
   echo $arg2;
}
?>
```
এই ফাংশনটিতে দুইটি আর্গুমেন্ট আছে ($arg1,$arg2) , অর্থাৎ এই ফাংশনটিকে কল করতে হলে ফাংশনের মধ্যে এই দুইটি আর্গুমেন্ট পাস করাতে হবে। অনেকটা এই রকম করে  `functionName('This is arg 1','This is 2');`, যদি ফাংশনটি কল করার সময় আর্গুমেন্টগুলো না থাকে তবে আর্গুমেন্ট মিসিং এরর দেখাবে।

পিএইচপি ফাংশনে ডিফল্ট আর্গুমেন্ট  ডিফাইন করে দেওয়া যায়।
#####যেমনঃ
```php
<?php
function functionName($arg1="ডিফল্ট আর্গুমেন্ট")
{
   echo $arg1;
}
?>
``` 
এই ফাংশনটি কল করার সময় শুধু কোন আর্গুমেন্টের ভ্যালু না দিলেও চলবে  (`functionName();`) , চাইলে আর্গুমেন্টের ভ্যালু দিয়ে  `$arg1` এর  ডিফল্ট ভ্যালু রিপ্লেস করা যাবে।

###রিটার্ন সহঃ

পুর্বে ব্যবহারিত  ইউজার ডিফাইন ফাংশনগুলোতে কোন ডাটা রিটার্ন করা হয় নি , শুধু সরাসরি ইকো করা হয়েছে। যদি কোন ইউজার ডিফাইন ফাংশন থেকে প্রাপ্ত ডাটা কোন ভ্যারিয়েবলে সংরক্ষণের প্রয়োজন হয় তখন ফাংশন থেকে ডাটা রিটার্নের প্রয়োজন হয়। তখন `return` ব্যবহার করে ডাটা রিটার্ন করা হয়।  ইউজার ডিফাইন ফাংশনে ডাটা রিটার্ন করলে অনেক সুবিদা পাওয়া যায়। যেমন আপনি চাইলে ডাটাকে ইকো করতে পারেন `echo functionName($arg1,$arg2);`,আবার চাইলে এটাকে ভ্যারিয়েবলে রাখতে পারেন অন্য কাজে ব্যবহারের জন্য `$myVar = functionName($arg1,$arg2);`। আপনি চাইলে এরে / অবজেক্ট / ভ্যারিয়েবল / রেফারেন্স রিটার্ন করতে পারেন।
```php
<?php
function functionName($arg1,$arg2)
{
   return $arg1.$arg2;
}
?>
```

রেফারেন্স সহ রিটার্নঃ
```php
<?php
function &returns_reference()
{
    return $someref;
}
$newref =& returns_reference();
?>
```
[উদাহরনটি পিএইচপি ম্যানুয়াল থেকে নেওয়া]

###ভ্যারিয়েবল ফাংশনঃ
অনেক সময় কোন ফাংশনকে ভ্যারিয়েবলের মাধ্যমে কল করা হয়ে থাকে, এই পদ্ধতিকে ভ্যারিয়েবল ফাংশন বলা হয়ে থাকে।
#####যেমনঃ
```php
<?php
function foo() {
    echo "In foo()<br />\n";
}

function bar($arg = '')
{
    echo "In bar(); argument was '$arg'.<br />\n";
}

// This is a wrapper function around echo
function echoit($string)
{
    echo $string;
}

$func = 'foo';
$func();        // This calls foo()

$func = 'bar';
$func('test');  // This calls bar()

$func = 'echoit';
$func('test');  // This calls echoit()
?>
```
[উদাহরনটি পিএইচপি ম্যানুয়াল থেকে নেওয়া]

###ফাংশনে ভ্যারিয়েবলের ব্যবহারঃ 
ইতি মধ্যে আমরা দেখেছি ফাংশনে কিভাবে আর্গুমেন্ট পাস করতে হয়। মুলত এই আর্গুমেন্ট গুলো হচ্ছে লোকাল ভ্যারিয়েবল। অর্থাৎ এই ভ্যারিয়েবলগুলোকে ফাংশনের বাইরে থেকে এক্সেস করা যাবে না। ফাংশনটি যখন রান হবে তখন এই ভ্যারিয়েবলগুলো মেমোরিতে প্রয়োজনীয় স্পেস এলোকেট করবে। পিএইচপিতে মুলত দুই ধরনের ভ্যারিয়েবল ব্যবহার করা হয়ে থাকে, একটি হচ্ছে `global` ভ্যারিয়েবল আর অন্যটি `local` ভ্যারিয়েবল। সাধারণত পিএইচপিতে ভ্যারিয়েবল গুলো গ্লোবাল টাইপ, অর্থাৎ আপনার প্রোগ্রামে আপনি একই নামে দুটি ভ্যারিয়েবল লিখলে ২য় টির দ্বারা প্রথমটির ভ্যালু প্রতিস্থাপিত হবে। ফাংশন / মেথডে ব্যবহারিত ভ্যারিয়েবলগুলো সাধারনত লোকাল ভ্যারিয়েবল হয়। অর্থাৎ ওই ভ্যারিয়েবলগুলোকে শুধুমাত্র ওই মেথড / ফাংশনের মধ্যে ব্যবহার করা যাবে। এছাড়া আরো এক ধরনের ভ্যারিয়েবল আছে যাকে `static` ভ্যারিয়েবল বলে। 
#####যেমনঃ 
```php
<?php
$myvar = 100; // $myvar একটি গ্লোবাল ভ্যারিয়েবল

function myFunc()
{
	$myvar = 50; // $myvar একটি লোকাল ভ্যারিয়েবল
}
?>
```

চাইলে গ্লোবাল ভ্যারিয়েবলগুলোকে ফাংশন / মেথডে ব্যবহার করা যায়। এর জন্য `global` স্টেটমেন্ট ব্যবহার করতে হবে।  নিচের উদাহরনটি দেখুনঃ
```php
<?php
$myvar = 100; // $myvar একটি গ্লোবাল ভ্যারিয়েবল

function myFunc()
{
	global $myvar;
	echo $myvar // $myvar একটি গ্লোবাল ভ্যারিয়েবল
}
?>
```

পিএইচপিতে যখন কোন ফাংশনে / মেথডে কোন ভ্যারিয়েবল ব্যবহার করা হয় তখন শুধুমাত্র ফাংশনটি কল হলে ভ্যারিয়েবলটি তৈরি হয় এবং কল শেষ হলে ধ্বংস হয়ে যায়। অনেক সময় আমাদের ওই ফাংশনটির ভ্যারিয়বলটির মান জানার দরকার হতে পারে। কিন্তু সাধারণত সেটা সম্ভব নয়। কারন ভ্যারিয়েবলটি ধ্বংস হয়ে গেছে। `static` স্টেটমেন্ট ব্যবহার করে ওই ভ্যারিয়েবলটিকে ধ্বংস হওয়া থেকে বিরত রাখা যাবে (শুধুমাত্র এক্সিকিউশন টাইমে)। নিচে একটি উদাহরন দেওয়া হলঃ

মনে করা যাক আমাদের একটি ফাংশন আছে যার নাম `query()` এখন আমাদের পুরো প্রোগ্রামে সকল ডাটাবেস কুয়েরির জন্য আমরা এই ফাংশনটি ব্যবহার করব। এই কারনে আমারা ফাংশনের মধ্যে একটি `static` ভ্যারিয়েবল ব্যবহার করব। যা কতবার এই ফাংশনটিকে কল করা হয়ে তার হিসাব রাখবে। 

```php
<?php
function query()
{
	static $count;
	$count += 1;
	$queryResult = "This is Query Result";
	return array('query' => $queryResult, 'count' => $count);
}
// চারবার কল করা হয়েছে।
var_dump(query());
var_dump(query());
var_dump(query());
var_dump(query());
?>
```
আউটপুটঃ 
```
array (size=2)
  'query' => string 'This is Query Result' (length=20)
  'count' => int 1
array (size=2)
  'query' => string 'This is Query Result' (length=20)
  'count' => int 2
array (size=2)
  'query' => string 'This is Query Result' (length=20)
  'count' => int 3
array (size=2)
  'query' => string 'This is Query Result' (length=20)
  'count' => int 4
```
###এনোনিমাস ফাংশনঃ
এই জাতীয় ফাংশনগুলোর কোন স্পেসিফিক নাম থাকে না।  উদাহরন হিসাবে নিচের কোডটি দেখুন।
```php
<?php
$data = function (){
    $val = array();
    for($i=0;$i<10;$i++)
    {
        $val[] = $i;
    }
    return $val;
};

var_dump($data());
?>
```
আনোনিমাস ফাংশনে চাইলে আর্গুমেন্ট ব্যবহার করা যায়, নিচের কোডটি দেখুনঃ 
```php
<?php
<?php
$data = function ($limit){
    $val = array();
    for($i=0;$i<$limit;$i++)
    {
        $val[] = $i;
    }
    return $val;
};

var_dump($data(20));
?>
```
###রিকার্সিভ ফাংশনঃ
কোন ফাংশন যখন নিজে নিজেকে কল করে তখন তাকে রিকার্সিভ ফাংশন বলা হয়ে থাকে।  নিচে একটি কোড দেওয়া হয়েছে যেটি  ধারার জনপ্রিয় সিরিজ Fibonacci এর n তম পদ পর্যন্ত বের করার ফাংশন। এই ফাংশনটি একটি রিকার্সিভ ফাংশন । এটি যতক্ষন পর্যন্ত `$count` এর মান  `$step` এর মানের সমান হচ্ছিল না ততক্ষন নিজেকে নিজে কল করেছে। 
>খেয়াল রাখতে হবে যদি রিকার্সিভ ফাংশন থেকে ডাটা রিটার্ন  করতে হয় তবে  মূল ফাংশনের ভেতরে ফাংশনটিকে কল করার সময় ফাংশনের সামনে `return` লাগিয়ে কল করতে হবে।


```php
<?php
function fibonacci($step)
{
    static $count,$firstNumber = 0,$secondNumber = 1,$fib = array();
    $count += 1;
    $step = $step + 1;
    if($firstNumber==0)
    {
        $fib[] = 0;
        $fib[] = 1;
    }
    $next_no = $firstNumber + $secondNumber;
    $fib[] = $next_no;
    $firstNumber = $secondNumber;
    $secondNumber = $next_no;
    $n = $step - $count;
    if($count <= $step)
    {
        return fibonacci($n); // নিজেকে কল করা হয়েছে
    }
    else
    {
        return $fib;
    }
}
var_dump(fibonacci(10));
?>
```

>নোটঃ ইউজার ডিফাইন ফাংশনগুলোকে একটি ফাইলে রাখা বেস্ট প্রাকটিস হিসাবে গন্য করা হয়। এতে একই নামের ফাংশন দু/বেশি বার ডিক্লেয়ার হওয়ার সম্ভবনা থাকে না। এই ফাইলটিকে `requere_once 'file.php';` ব্যবহার করে অন্য ফাইলে এড করতে হয়। 